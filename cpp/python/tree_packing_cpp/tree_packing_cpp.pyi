"""
C++ implementation of tree packing optimization
"""
from __future__ import annotations
import numpy
import typing
__all__: list[str] = ['ALNS', 'CENTER_R', 'CENTER_Y', 'Chain', 'CoolingSchedule', 'GlobalState', 'NoiseOptimizer', 'Optimizer', 'OptimizerState', 'PI', 'Problem', 'RNG', 'RandomRecreate', 'RandomRuin', 'SimulatedAnnealing', 'Solution', 'SolutionEval', 'SpatialRuin', 'THR', 'TreeParams', 'TreeParamsSoA', 'Vec2', 'run_optimization']
class ALNS(Optimizer):
    def __init__(self, ruin_operators: list[Optimizer], recreate_operators: list[Optimizer], reaction_factor: float = 0.009999999776482582, reward_improve: float = 1.0, reward_no_improve: float = 0.0, min_weight: float = 0.0010000000474974513, verbose: bool = False) -> None:
        ...
class Chain(Optimizer):
    def __init__(self, optimizers: list[Optimizer], verbose: bool = False) -> None:
        ...
class CoolingSchedule:
    """
    Members:
    
      Exponential
    
      Linear
    
      Logarithmic
    """
    Exponential: typing.ClassVar[CoolingSchedule]  # value = <CoolingSchedule.Exponential: 0>
    Linear: typing.ClassVar[CoolingSchedule]  # value = <CoolingSchedule.Linear: 1>
    Logarithmic: typing.ClassVar[CoolingSchedule]  # value = <CoolingSchedule.Logarithmic: 2>
    __members__: typing.ClassVar[dict[str, CoolingSchedule]]  # value = {'Exponential': <CoolingSchedule.Exponential: 0>, 'Linear': <CoolingSchedule.Linear: 1>, 'Logarithmic': <CoolingSchedule.Logarithmic: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class GlobalState:
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: SolutionEval) -> None:
        ...
    def best_feasible_score(self) -> float:
        ...
    def best_score(self) -> float:
        ...
    def iteration(self) -> int:
        ...
    def iters_since_feasible_improvement(self) -> int:
        ...
    def iters_since_improvement(self) -> int:
        ...
    def maybe_update_best(self, arg0: Problem, arg1: SolutionEval) -> None:
        ...
    def mu(self) -> float:
        ...
    def next(self) -> None:
        ...
    def random_float(self) -> float:
        ...
    def random_int(self, arg0: int, arg1: int) -> int:
        ...
    def set_mu(self, arg0: float) -> None:
        ...
    def set_tolerance(self, arg0: float) -> None:
        ...
    def tolerance(self) -> float:
        ...
class NoiseOptimizer(Optimizer):
    def __init__(self, noise_level: float = 0.009999999776482582, verbose: bool = False) -> None:
        ...
class Optimizer:
    def apply(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState, arg3: RNG) -> tuple:
        ...
    def apply_inplace(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState, arg3: RNG) -> None:
        ...
    def init_state(self, arg0: SolutionEval) -> OptimizerState:
        ...
    def run(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState, arg3: int) -> tuple:
        ...
    def run_inplace(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState, arg3: int) -> None:
        ...
    def set_problem(self, arg0: Problem) -> None:
        ...
    def step(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState) -> tuple:
        ...
    def step_inplace(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState) -> None:
        ...
class OptimizerState:
    def __init__(self) -> None:
        ...
class Problem:
    @staticmethod
    def create_tree_packing_problem(side: float = -1.0) -> Problem:
        ...
    def __init__(self) -> None:
        ...
    def eval(self, arg0: Solution) -> SolutionEval:
        ...
    def eval_update(self, arg0: Solution, arg1: SolutionEval, arg2: list[int]) -> SolutionEval:
        ...
    def max_pos(self) -> float:
        ...
    def min_pos(self) -> float:
        ...
    def objective(self, arg0: Solution) -> float:
        ...
    def score(self, arg0: SolutionEval, arg1: ...) -> float:
        ...
class RNG:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def choice(self, arg0: int, arg1: int) -> list[int]:
        ...
    def permutation(self, arg0: int) -> list[int]:
        ...
    def randint(self, arg0: int, arg1: int) -> int:
        ...
    def split(self) -> RNG:
        ...
    @typing.overload
    def uniform(self) -> float:
        ...
    @typing.overload
    def uniform(self, arg0: float, arg1: float) -> float:
        ...
class RandomRecreate(Optimizer):
    def __init__(self, max_recreate: int = 1, box_size: float = 5.0, delta: float = 0.3499999940395355, verbose: bool = False) -> None:
        ...
class RandomRuin(Optimizer):
    def __init__(self, n_remove: int = 1, verbose: bool = False) -> None:
        ...
class SimulatedAnnealing(Optimizer):
    def __init__(self, inner_optimizer: Optimizer, initial_temp: float = 1.0, min_temp: float = 9.999999974752427e-07, cooling_schedule: CoolingSchedule = ..., cooling_rate: float = 0.9950000047683716, patience: int = -1, verbose: bool = False) -> None:
        ...
class Solution:
    @staticmethod
    def init_empty(arg0: int) -> Solution:
        ...
    @staticmethod
    def init_random(num_trees: int, side: float = 10.0, seed: int = 42) -> Solution:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def get_params(self, arg0: int) -> TreeParams:
        ...
    def n_missing(self) -> int:
        ...
    @typing.overload
    def params(self) -> TreeParamsSoA:
        ...
    @typing.overload
    def params(self) -> TreeParamsSoA:
        ...
    def recompute_cache(self) -> None:
        ...
    def reg(self) -> float:
        ...
    def set_nan(self, arg0: int) -> None:
        ...
    def set_params(self, arg0: int, arg1: TreeParams) -> None:
        ...
    def size(self) -> int:
        ...
class SolutionEval:
    bounds_violation: float
    intersection_violation: float
    objective: float
    solution: Solution
    def __init__(self) -> None:
        ...
    def copy_from(self, arg0: SolutionEval) -> None:
        ...
    def n_missing(self) -> int:
        ...
    def reg(self) -> float:
        ...
    def total_violation(self) -> float:
        ...
class SpatialRuin(Optimizer):
    def __init__(self, n_remove: int = 1, verbose: bool = False) -> None:
        ...
class TreeParams:
    angle: float
    pos: Vec2
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2, arg1: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    def is_nan(self) -> bool:
        ...
class TreeParamsSoA:
    angle: numpy.ndarray[numpy.float32]
    x: numpy.ndarray[numpy.float32]
    y: numpy.ndarray[numpy.float32]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def count_nan(self) -> int:
        ...
    def to_numpy(self) -> tuple[numpy.ndarray, numpy.ndarray]:
        ...
    def get(self, arg0: int) -> TreeParams:
        ...
    def is_nan(self, arg0: int) -> bool:
        ...
    def set(self, arg0: int, arg1: TreeParams) -> None:
        ...
    def set_nan(self, arg0: int) -> None:
        ...
    def size(self) -> int:
        ...
class Vec2:
    x: float
    y: float
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
def run_optimization(problem: Problem, initial_solution: Solution, num_iterations: int = 1000, seed: int = 42, n_remove: int = 1, max_recreate: int = 1, initial_temp: float = 1000.0, cooling_rate: float = 0.9994999766349792, verbose: bool = False) -> tuple:
    ...
CENTER_R: float = 0.5029000043869019
CENTER_Y: float = 0.2971999943256378
PI: float = 3.1415927410125732
THR: float = 1.0058000087738037
