"""
C++ implementation of tree packing optimization
"""
from __future__ import annotations
import numpy
import typing
__all__: list[str] = ['ALNS', 'CENTER_R', 'CENTER_Y', 'CellRuin', 'Chain', 'CompactionOptimizer', 'CoolingSchedule', 'GlobalState', 'IntersectionTreeFilter', 'LocalSearchOptimizer', 'NoiseOptimizer', 'Optimizer', 'OptimizerState', 'PI', 'Problem', 'RNG', 'RandomRecreate', 'RandomRuin', 'SimulatedAnnealing', 'Solution', 'SolutionEval', 'SqueezeOptimizer', 'THR', 'TreeParams', 'TreeParamsSoA', 'Vec2', 'params_to_figures', 'run_optimization', 'triangle_pair_intersection_scores']
def params_to_figures(params: TreeParamsSoA) -> numpy.ndarray[numpy.float32]:
    ...
def triangle_pair_intersection_scores(a: TreeParams, b: TreeParams, eps: float = 1.0000000116860974e-07) -> numpy.ndarray[numpy.float32]:
    ...
class ALNS(Optimizer):
    def __init__(self, ruin_operators: list[Optimizer], recreate_operators: list[Optimizer], reaction_factor: float = 0.009999999776482582, reward_improve: float = 1.0, reward_no_improve: float = 0.0, min_weight: float = 0.0010000000474974513, verbose: bool = False) -> None:
        ...
class Chain(Optimizer):
    def __init__(self, optimizers: list[Optimizer], verbose: bool = False) -> None:
        ...
class CoolingSchedule:
    """
    Members:
    
      Exponential
    
      Linear
    
      Logarithmic
    """
    Exponential: typing.ClassVar[CoolingSchedule]  # value = <CoolingSchedule.Exponential: 0>
    Linear: typing.ClassVar[CoolingSchedule]  # value = <CoolingSchedule.Linear: 1>
    Logarithmic: typing.ClassVar[CoolingSchedule]  # value = <CoolingSchedule.Logarithmic: 2>
    __members__: typing.ClassVar[dict[str, CoolingSchedule]]  # value = {'Exponential': <CoolingSchedule.Exponential: 0>, 'Linear': <CoolingSchedule.Linear: 1>, 'Logarithmic': <CoolingSchedule.Logarithmic: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class GlobalState:
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: SolutionEval) -> None:
        ...
    def best_feasible_score(self) -> float:
        ...
    def best_feasible_solution(self) -> SolutionEval | None:
        ...
    def best_score(self) -> float:
        ...
    def best_solution(self) -> SolutionEval | None:
        ...
    def iteration(self) -> int:
        ...
    def iters_since_feasible_improvement(self) -> int:
        ...
    def iters_since_improvement(self) -> int:
        ...
    def maybe_update_best(self, arg0: Problem, arg1: SolutionEval) -> None:
        ...
    def mu(self) -> float:
        ...
    def next(self) -> None:
        ...
    def random_float(self) -> float:
        ...
    def random_int(self, arg0: int, arg1: int) -> int:
        ...
    def set_mu(self, arg0: float) -> None:
        ...
    def set_tolerance(self, arg0: float) -> None:
        ...
    def tolerance(self) -> float:
        ...
class NoiseOptimizer(Optimizer):
    def __init__(self, noise_level: float = 0.009999999776482582, verbose: bool = False) -> None:
        ...
class SqueezeOptimizer(Optimizer):
    def __init__(self, min_scale: float = 0.05000000074505806, shrink: float = 0.9200000166893005, bisect_iters: int = 18, axis_rounds: int = 3, verbose: bool = False) -> None:
        ...
class CompactionOptimizer(Optimizer):
    def __init__(self, iters_per_tree: int = 8, verbose: bool = False) -> None:
        ...
class LocalSearchOptimizer(Optimizer):
    def __init__(self, iters_per_tree: int = 18, verbose: bool = False) -> None:
        ...
class Optimizer:
    def apply(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState, arg3: RNG) -> tuple:
        ...
    def apply_inplace(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState, arg3: RNG) -> None:
        ...
    def init_state(self, arg0: SolutionEval) -> OptimizerState:
        ...
    def run(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState, arg3: int) -> tuple:
        ...
    def run_inplace(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState, arg3: int) -> None:
        ...
    def set_problem(self, arg0: Problem) -> None:
        ...
    def step(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState) -> tuple:
        ...
    def step_inplace(self, arg0: SolutionEval, arg1: OptimizerState, arg2: GlobalState) -> None:
        ...
class OptimizerState:
    def __init__(self) -> None:
        ...
class Problem:
    @staticmethod
    def create_tree_packing_problem(side: float = -1.0) -> Problem:
        ...
    def __init__(self) -> None:
        ...
    def eval(self, arg0: Solution) -> SolutionEval:
        ...
    def eval_update(self, arg0: Solution, arg1: SolutionEval, arg2: list[int]) -> SolutionEval:
        ...
    def max_pos(self) -> float:
        ...
    def min_pos(self) -> float:
        ...
    def objective(self, arg0: Solution) -> float:
        ...
    def score(self, arg0: SolutionEval, arg1: ...) -> float:
        ...
class RNG:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def choice(self, arg0: int, arg1: int) -> list[int]:
        ...
    def permutation(self, arg0: int) -> list[int]:
        ...
    def randint(self, arg0: int, arg1: int) -> int:
        ...
    def split(self) -> RNG:
        ...
    @typing.overload
    def uniform(self) -> float:
        ...
    @typing.overload
    def uniform(self, arg0: float, arg1: float) -> float:
        ...
class RandomRecreate(Optimizer):
    def __init__(self, max_recreate: int = 1, box_size: float = 5.0, delta: float = 0.3499999940395355, verbose: bool = False) -> None:
        ...
class RandomRuin(Optimizer):
    def __init__(self, n_remove: int = 1, verbose: bool = False) -> None:
        ...
class SimulatedAnnealing(Optimizer):
    def __init__(self, inner_optimizer: Optimizer, initial_temp: float = 1.0, min_temp: float = 9.999999974752427e-07, cooling_schedule: CoolingSchedule = ..., cooling_rate: float = 0.9950000047683716, patience: int = -1, verbose: bool = False) -> None:
        ...
class Conditional(Optimizer):
    """
    Conditional meta-optimizer that applies inner optimizer only when ALL conditions are met.

    All conditions use logical AND - the optimizer runs only if all enabled conditions are true.
    Set a condition to 0 to disable it.

    Args:
        inner_optimizer: The optimizer to conditionally apply.
        every_n: Run when iteration % every_n == 0 (0 = disabled).
        min_iters_since_improvement: Run when iters_since_improvement >= this value (0 = disabled).
        min_iters_since_feasible_improvement: Run when iters_since_feasible_improvement >= this value (0 = disabled).
        verbose: Print debug messages.

    Examples:
        # Run expensive optimizer every 100 iterations
        opt = Conditional(expensive_opt, every_n=100)

        # Run diversification when stuck for 50 iterations
        opt = Conditional(diversify_opt, min_iters_since_improvement=50)

        # Run every 10 iterations AND when stuck for 20 iterations
        opt = Conditional(opt, every_n=10, min_iters_since_improvement=20)
    """
    def __init__(self, inner_optimizer: Optimizer, every_n: int = 0, min_iters_since_improvement: int = 0, min_iters_since_feasible_improvement: int = 0, verbose: bool = False) -> None:
        ...
    @property
    def every_n(self) -> int:
        ...
    @property
    def min_iters_since_improvement(self) -> int:
        ...
    @property
    def min_iters_since_feasible_improvement(self) -> int:
        ...
class Solution:
    @staticmethod
    def init_empty(arg0: int) -> Solution:
        ...
    @staticmethod
    def init_random(num_trees: int, side: float = 10.0, seed: int = 42) -> Solution:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def aabbs(self) -> numpy.ndarray[numpy.float32]:
        ...
    def centers(self) -> numpy.ndarray[numpy.float32]:
        ...
    def figures(self) -> numpy.ndarray[numpy.float32]:
        ...
    def get_params(self, arg0: int) -> TreeParams:
        ...
    def max_abs(self) -> numpy.ndarray[numpy.float32]:
        ...
    def n_missing(self) -> int:
        ...
    @typing.overload
    def params(self) -> TreeParamsSoA:
        ...
    @typing.overload
    def params(self) -> TreeParamsSoA:
        ...
    def recompute_cache(self) -> None:
        ...
    def reg(self) -> float:
        ...
    def set_nan(self, arg0: int) -> None:
        ...
    def set_params(self, arg0: int, arg1: TreeParams) -> None:
        ...
    def size(self) -> int:
        ...
class IntersectionTreeFilter:
    def __init__(self) -> None:
        ...
    def features_for(self, solution: Solution, idx_a: int, idx_b: int) -> tuple[bool, numpy.ndarray[numpy.float32]]:
        ...
    def leaf_index_for(self, solution: Solution, idx_a: int, idx_b: int) -> int:
        ...
    def leaf_pred_for(self, solution: Solution, idx_a: int, idx_b: int) -> tuple[bool, int, numpy.ndarray[numpy.uint8]]:
        ...
    def ready(self) -> bool:
        ...
    def triangle_pairs_for(self, solution: Solution, idx_a: int, idx_b: int) -> list[tuple[int, int]]:
        ...
class SolutionEval:
    bounds_violation: float
    intersection_violation: float
    objective: float
    solution: Solution
    def __init__(self) -> None:
        ...
    def intersection_map(self) -> list[list[tuple[int, float]] | None]:
        ...
    def intersection_matrix(self) -> numpy.ndarray[numpy.float32]:
        ...
    def copy_from(self, arg0: SolutionEval) -> None:
        ...
    def n_missing(self) -> int:
        ...
    def reg(self) -> float:
        ...
    def total_violation(self) -> float:
        ...
class CellRuin(Optimizer):
    def __init__(self, n_remove: int = 1, verbose: bool = False) -> None:
        ...
class TreeParams:
    angle: float
    pos: Vec2
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2, arg1: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    def is_nan(self) -> bool:
        ...
class TreeParamsSoA:
    angle: numpy.ndarray[numpy.float32]
    x: numpy.ndarray[numpy.float32]
    y: numpy.ndarray[numpy.float32]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def count_nan(self) -> int:
        ...
    def to_numpy(self) -> tuple[numpy.ndarray, numpy.ndarray]:
        ...
    def get(self, arg0: int) -> TreeParams:
        ...
    def is_nan(self, arg0: int) -> bool:
        ...
    def set(self, arg0: int, arg1: TreeParams) -> None:
        ...
    def set_nan(self, arg0: int) -> None:
        ...
    def size(self) -> int:
        ...
class Vec2:
    x: float
    y: float
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
def run_optimization(problem: Problem, initial_solution: Solution, num_iterations: int = 1000, seed: int = 42, n_remove: int = 1, max_recreate: int = 1, initial_temp: float = 1000.0, cooling_rate: float = 0.9994999766349792, verbose: bool = False) -> tuple:
    ...
CENTER_R: float = 0.5029000043869019
CENTER_Y: float = 0.2971999943256378
PI: float = 3.1415927410125732
THR: float = 1.0058000087738037
